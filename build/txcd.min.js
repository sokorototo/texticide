!function(){class t{constructor(e,r=[]){if(!Array.isArray(r))throw new Error("Expected parameter for Diction should be an array!");this.name=String(e),this.patterns=t.parse(r)}static parse(t){let e=t.slice(),r=[];for(let t=0;t<e.length;t++){const i=e[t];r.push(i)}return r}}const e={Diction:t,Sanitizer:class{constructor(t=[],e={}){if(!Array.isArray(t)||"object"!=typeof e)throw new Error("Sanitizer parameters are not of type: fn(Array, Object)");if(this.dictionary=t,this.defaultLevel=e.defaultLevel||4,this.replacer=e.replacer||"*","string"!=typeof this.replacer&&"function"!=typeof this.replacer)throw new Error("{}.replacer must either be a string or a function")}locate(t,e=this.defaultLevel,r=[]){let i=[];for(let n=0;n<this.dictionary.length;n++){const a=this.dictionary[n];for(let n=0;n<a.patterns.length;n++){const o=a.patterns[n];if(r.includes(o.id))continue;if(o.level>=e)continue;let c=o.patterns;for(let e=0;e<c.length;e++){const r=c[e];let n=!1;for(;!n;){let e={diction:a.name,pattern:r,word:o.id},c=r.exec(t);(n=!c)||i.push(Object.assign({match:[c[0],c.index,c[0].length+c.index]},e))}}}}return i}clean(t,e,r){let i=this.locate(t,e,r),n=this.replacer;return i.forEach(function(e){let r;switch(typeof n){case"string":let t="",i=e.match[2]-e.match[1],a=n.split("");for(let e=0;e<i;e++)t+=a[Math.floor(a.length*Math.random())];r=t;break;case"function":r=n(e.match[0])}let i=t.slice(0,e.match[1]),a=t.slice(e.match[2]);t=i+r+a}),t}}};"function"==typeof define&&define.amd?define(e):"object"==typeof exports?module.exports=e:globalThis.Texticide=e}();