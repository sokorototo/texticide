class Diction{constructor(t,e=[]){if(!Array.isArray(e))throw new Error("Expected parameter for Diction should be an array!");this.name=String(t),this.patterns=Diction.parse(e)}static parse(t){let e=t.slice(),r=[];for(let t=0;t<e.length;t++){const i=e[t];r.push(i)}return r}}class Sanitizer{constructor(t=[],e={}){if(!Array.isArray(t)||"object"!=typeof e)throw new Error("Sanitizer parameters are not of type: fn(Array, Object)");if(this.dictionary=t,this.defaultLevel=e.defaultLevel||4,this.replacer=e.replacer||"*","string"!=typeof this.replacer&&"function"!=typeof this.replacer)throw new Error("{}.replacer must either be a string or a function")}locate(t,e=this.defaultLevel,r=[]){let i=[];for(let n=0;n<this.dictionary.length;n++){const a=this.dictionary[n];for(let n=0;n<a.patterns.length;n++){const c=a.patterns[n];if(r.includes(c.id))continue;if(c.level>=e)continue;let o=c.patterns;for(let e=0;e<o.length;e++){const r=o[e];let n=!1;for(;!n;){let e={diction:a.name,pattern:r,word:c.id},o=r.exec(t);(n=!o)||i.push(Object.assign({match:[o[0],o.index,o[0].length+o.index]},e))}}}}return i}clean(t,e,r){let i=this.locate(t,e,r),n=this.replacer;return i.forEach(function(e){let r;switch(typeof n){case"string":let t="",i=e.match[2]-e.match[1],a=n.split("");for(let e=0;e<i;e++)t+=a[Math.floor(a.length*Math.random())];r=t;break;case"function":r=n(e.match[0])}let i=t.slice(0,e.match[1]),a=t.slice(e.match[2]);t=i+r+a}),t}}const Texticide={Diction:Diction,Sanitizer:Sanitizer};export default Texticide;