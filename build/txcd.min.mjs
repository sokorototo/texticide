class Diction{constructor(t,e=[]){if(!Array.isArray(e))throw new Error("Expected parameter for Diction should be an array!");this.name=String(t),this.patterns=Diction.parse(e)}static parse(t){let e=t.slice(),r=[];for(let t=0;t<e.length;t++){var a=e[t];r.push(a)}return r}}class Sanitizer{constructor(t=[],e={}){if(!Array.isArray(t)||"object"!=typeof e)throw new Error("Sanitizer parameters are not of type: fn(Array, Object)");if(this.dictionary=t,this.defaultLevel=e.defaultLevel||4,this.replacer=e.replacer||"*","string"!=typeof this.replacer&&"function"!=typeof this.replacer)throw new Error("{}.replacer must either be a string or a function")}locate(r,e=this.defaultLevel,a=[]){let i=[];for(let t=0;t<this.dictionary.length;t++){var n=this.dictionary[t];for(let t=0;t<n.patterns.length;t++){var c=n.patterns[t];if(!a.includes(c.id)&&!(c.level>=e)){var o=c.patterns;for(let e=0;e<o.length;e++){const h=o[e];let t=!1;for(var s={diction:n.name,pattern:h,word:c.id};!t;){var l=h.exec(r);t=!l,t||i.push(Object.assign({match:[l[0],l.index,l[0].length+l.index]},s))}}}}}return i}clean(c,t,e){let r=this.locate(c,t,e),o=this.replacer;return r.forEach(function(t){let r;switch(typeof o){case"string":let e="";var a=t.match[2]-t.match[1],i=o.split("");for(let t=0;t<a;t++)e+=i[Math.floor(i.length*Math.random())];r=e;break;case"function":r=o(t.match[0])}var e=c.slice(0,t.match[1]),n=c.slice(t.match[2]);c=e+r+n}),c}}var txcd_max={Sanitizer:Sanitizer,Diction:Diction};export default txcd_max;
